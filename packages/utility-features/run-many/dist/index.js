(()=>{"use strict";var e={n:n=>{var t=n&&n.__esModule?()=>n.default:()=>n;return e.d(t,{a:t}),t},d:(n,t)=>{for(var i in t)e.o(t,i)&&!e.o(n,i)&&Object.defineProperty(n,i,{enumerable:!0,get:t[i]})},o:(e,n)=>Object.prototype.hasOwnProperty.call(e,n),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},n={};e.r(n),e.d(n,{runManyFor:()=>h,runManySyncFor:()=>m});const t=require("@k8slens/utilities"),i=require("events");var r=e.n(i);const s=require("uuid"),o=require("assert");var a=e.n(o);const c=(e,n,t,i)=>{i.add(t);const r=n.get(t);a()(r,`Runnable graph does not contain node with id="${t}"`);for(const t of r.values()){if(e.includes(t))throw new Error(`Cycle in runnable graph: "${e.join('" -> "')}" -> "${t}"`);c([...e,t],n,t,i)}};function d(e,n){const i=s.v4(),r=new Map,o=new Set,a=(0,t.getOrInsertSetFor)(r);for(const e of n)if(a(e.id),0===e.runAfter.length)a(i).add(e.id);else for(const n of e.runAfter)a(n.id).add(e.id);a(i),c([],r,i,o);for(const i of r.keys())if(!o.has(i)){const r=n.find((e=>e.id===i));if(!r)throw new Error(`Runnable "${i}" is not part of the injection token "${e}"`);const s=[r.runAfter].flat().filter(t.isDefined).map((e=>e.id)).join('", "');throw new Error(`Runnable "${i}" is unreachable for injection token "${e}": run afters "${s}" are a part of different injection tokens.`)}}const f=e=>{const n=(i,r)=>({id:i.id,run:r.run,runAfter:[r.runAfter].flat().filter(t.isDefined).map((t=>n(t,e.inject(t))))});return e=>n(e.meta,e.instance)};class u{constructor(){Object.defineProperty(this,"finishedIds",{enumerable:!0,configurable:!0,writable:!0,value:new Map}),Object.defineProperty(this,"events",{enumerable:!0,configurable:!0,writable:!0,value:new(r())})}initFinishingPromise(e){return(0,t.getOrInsert)(this.finishedIds,e,new Promise((n=>{const t=i=>{i===e&&(n(),this.events.removeListener("finish",t))};this.events.addListener("finish",t)})))}setFinished(e){this.initFinishingPromise(e),this.events.emit("finish",e)}async blockOn(e){await this.initFinishingPromise(e)}}const l=e=>{const n=new u;return async t=>{for(const e of t.runAfter)await n.blockOn(e.id);await t.run(e),n.setFinished(t.id)}};function h(e){const n=f(e);return t=>async i=>{const r=l(i),s=e.injectManyWithMeta(t).map((e=>n(e)));d(t.id,s),await Promise.all(s.map(r))}}class b{constructor(){Object.defineProperty(this,"finishedIds",{enumerable:!0,configurable:!0,writable:!0,value:new Set}),Object.defineProperty(this,"events",{enumerable:!0,configurable:!0,writable:!0,value:new(r())})}setFinished(e){this.finishedIds.add(e),this.events.emit(e)}onceParentsAreFinished(e,n,t){const i=new Map,r=()=>{0===i.size&&(t(),this.setFinished(e))};for(const e of n){if(this.finishedIds.has(e))continue;const n=()=>{this.events.removeListener(e,n),i.delete(e),r()};i.set(e,n),this.events.once(e,n)}r()}}const w=e=>{const n=new b;return t=>{n.onceParentsAreFinished(t.id,t.runAfter.map((e=>e.id)),(()=>t.run(e)))}};function m(e){const n=f(e);return t=>i=>{const r=w(i),s=e.injectManyWithMeta(t).map(n);d(t.id,s),s.forEach(r)}}module.exports=n})();